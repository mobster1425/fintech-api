// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: transaction.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createTransaction = `-- name: CreateTransaction :one
INSERT INTO transaction (
  sender_wallet_id,
  receiver_wallet_id,
  amount,
charge,
type,
sendamount,
receiveamount,
note,
status
) VALUES (
  $1, $2, $3, $4, $5, $6, $7, $8,$9
) RETURNING id, createdat, updatedat, sender_wallet_id, receiver_wallet_id, charge, amount, sendamount, receiveamount, note, type, status
`

type CreateTransactionParams struct {
	SenderWalletID   int64                 `json:"sender_wallet_id"`
	ReceiverWalletID pgtype.Int8           `json:"receiver_wallet_id"`
	Amount           pgtype.Int8           `json:"amount"`
	Charge           pgtype.Int8           `json:"charge"`
	Type             NullTransactionType   `json:"type"`
	Sendamount       pgtype.Int8           `json:"sendamount"`
	Receiveamount    pgtype.Int8           `json:"receiveamount"`
	Note             pgtype.Text           `json:"note"`
	Status           NullTransactionStatus `json:"status"`
}

func (q *Queries) CreateTransaction(ctx context.Context, arg CreateTransactionParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, createTransaction,
		arg.SenderWalletID,
		arg.ReceiverWalletID,
		arg.Amount,
		arg.Charge,
		arg.Type,
		arg.Sendamount,
		arg.Receiveamount,
		arg.Note,
		arg.Status,
	)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.SenderWalletID,
		&i.ReceiverWalletID,
		&i.Charge,
		&i.Amount,
		&i.Sendamount,
		&i.Receiveamount,
		&i.Note,
		&i.Type,
		&i.Status,
	)
	return i, err
}

const getTransaction = `-- name: GetTransaction :one
SELECT id, createdat, updatedat, sender_wallet_id, receiver_wallet_id, charge, amount, sendamount, receiveamount, note, type, status FROM transaction
WHERE id = $1 LIMIT 1
`

func (q *Queries) GetTransaction(ctx context.Context, id int64) (Transaction, error) {
	row := q.db.QueryRow(ctx, getTransaction, id)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.SenderWalletID,
		&i.ReceiverWalletID,
		&i.Charge,
		&i.Amount,
		&i.Sendamount,
		&i.Receiveamount,
		&i.Note,
		&i.Type,
		&i.Status,
	)
	return i, err
}

const listTransactions = `-- name: ListTransactions :many
SELECT id, createdat, updatedat, sender_wallet_id, receiver_wallet_id, charge, amount, sendamount, receiveamount, note, type, status FROM transaction
WHERE 
    sender_wallet_id = $1 OR
    receiver_wallet_id = $2
ORDER BY id
LIMIT $3
OFFSET $4
`

type ListTransactionsParams struct {
	SenderWalletID   int64       `json:"sender_wallet_id"`
	ReceiverWalletID pgtype.Int8 `json:"receiver_wallet_id"`
	Limit            int32       `json:"limit"`
	Offset           int32       `json:"offset"`
}

func (q *Queries) ListTransactions(ctx context.Context, arg ListTransactionsParams) ([]Transaction, error) {
	rows, err := q.db.Query(ctx, listTransactions,
		arg.SenderWalletID,
		arg.ReceiverWalletID,
		arg.Limit,
		arg.Offset,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []Transaction{}
	for rows.Next() {
		var i Transaction
		if err := rows.Scan(
			&i.ID,
			&i.Createdat,
			&i.Updatedat,
			&i.SenderWalletID,
			&i.ReceiverWalletID,
			&i.Charge,
			&i.Amount,
			&i.Sendamount,
			&i.Receiveamount,
			&i.Note,
			&i.Type,
			&i.Status,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateTransactionReceiverWallet = `-- name: UpdateTransactionReceiverWallet :one
UPDATE transaction
SET receiver_wallet_id = $2
WHERE id = $1
RETURNING id, createdat, updatedat, sender_wallet_id, receiver_wallet_id, charge, amount, sendamount, receiveamount, note, type, status
`

type UpdateTransactionReceiverWalletParams struct {
	ID               int64       `json:"id"`
	ReceiverWalletID pgtype.Int8 `json:"receiver_wallet_id"`
}

func (q *Queries) UpdateTransactionReceiverWallet(ctx context.Context, arg UpdateTransactionReceiverWalletParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionReceiverWallet, arg.ID, arg.ReceiverWalletID)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.SenderWalletID,
		&i.ReceiverWalletID,
		&i.Charge,
		&i.Amount,
		&i.Sendamount,
		&i.Receiveamount,
		&i.Note,
		&i.Type,
		&i.Status,
	)
	return i, err
}

const updateTransactionStatus = `-- name: UpdateTransactionStatus :one
UPDATE transaction
SET status = $2
WHERE id = $1
RETURNING id, createdat, updatedat, sender_wallet_id, receiver_wallet_id, charge, amount, sendamount, receiveamount, note, type, status
`

type UpdateTransactionStatusParams struct {
	ID     int64                 `json:"id"`
	Status NullTransactionStatus `json:"status"`
}

func (q *Queries) UpdateTransactionStatus(ctx context.Context, arg UpdateTransactionStatusParams) (Transaction, error) {
	row := q.db.QueryRow(ctx, updateTransactionStatus, arg.ID, arg.Status)
	var i Transaction
	err := row.Scan(
		&i.ID,
		&i.Createdat,
		&i.Updatedat,
		&i.SenderWalletID,
		&i.ReceiverWalletID,
		&i.Charge,
		&i.Amount,
		&i.Sendamount,
		&i.Receiveamount,
		&i.Note,
		&i.Type,
		&i.Status,
	)
	return i, err
}
